#!/usr/bin/env python

"""
@author: L3o G3tz
@email : l3og3tz@gmail.com
@version: 1.0
@attention: Tested under python 2.7+
"""

import sys
import time
import os
import RSA
from multiprocessing.pool import ThreadPool

MSG_END_MARKER = ";;"
IP_BAN_LIST = []
FILE_TRANSFER_BEGIN_CODE = "FILE_IN"
FILE_TRANSFER_END_CODE = "FILE_OUT"
APPROVAL_CODE = "FILE_IN_APPROVE"
DENIAL_CODE = "FILE_IN_DENIED"

def clear_screen():
    '''
    Clears the screen when program starts to give nice output
    
    '''
    if("windows" in sys.platform.lower()):
        os.system("cls")
    elif ("linux" or "unix" or "darwin" in sys.platform.lower()):
        os.system("clear")

def draw_server_logo():
    '''
    Draws the ASCII written logo of Secure Chat Server
    '''
    
    print"""
        
         \033[1;34m/*********************************************************************\\\033[1;m
         \033[1;34m*     ____  ____  ___  _  _  ____  ____     ___  _  _   __  ____      *\033[1;m
         \033[1;34m*    / ___)(  __)/ __)/ )( \(  _ \(  __)   / __)/ )( \ / _\(_  _)     *\033[1;m
         \033[1;34m*    \___ \ ) _)( (__ ) \/ ( )   / ) _)   ( (__ ) __ (/    \ )(       *\033[1;m
         \033[1;34m*    (____/(____)\___)\____/(__\_)(____)   \___)\_)(_/\_/\_/(__)      *\033[1;m
         \033[1;34m*                              SERVER                                 *\033[1;m
         \033[1;34m\\*********************************************************************/\033[1;m
        
        """

def draw_client_logo():
    '''
    Draws the ASCII written logo of Secure Chat
    '''
    
    print"""
        
         \033[1;34m/*********************************************************************\\\033[1;m
         \033[1;34m*     ____  ____  ___  _  _  ____  ____     ___  _  _   __  ____      *\033[1;m
         \033[1;34m*    / ___)(  __)/ __)/ )( \(  _ \(  __)   / __)/ )( \ / _\(_  _)     *\033[1;m
         \033[1;34m*    \___ \ ) _)( (__ ) \/ ( )   / ) _)   ( (__ ) __ (/    \ )(       *\033[1;m
         \033[1;34m*    (____/(____)\___)\____/(__\_)(____)   \___)\_)(_/\_/\_/(__)      *\033[1;m
         \033[1;34m*                              CLIENT                                 *\033[1;m
         \033[1;34m\\*********************************************************************/\033[1;m
        
        """
   

def display_processing_cursor(the_message, the_numof_secs=2, the_timeto_sleep=.5):
        '''
        Displays a rotating cursor to indicate processing.
        
        '''
        print "\nPlease wait a moment", the_message, "..."
        syms = ['\\', '|', '/', '-']
        bs = '\b'

        for _ in range(the_numof_secs):
            for sym in syms:
                sys.stdout.write(bs + "%s" % sym)
                sys.stdout.flush()
                time.sleep(.5)
                
def generate_my_keys(the_n, the_e, the_d):
    
    '''
    Starts a new thread to handle key generation. More versatile
    than just calling RSA.newKey as it runs on a different thread.
    '''
    pool = ThreadPool(processes=1)
    async_result = pool.apply_async(RSA.newKey, (the_n, the_e, the_d))  # tuple of args for foo

    (n, e, d) = async_result.get()  # get the return value from your function.
   
    return (n, e, d)

def combine_cipherblocks_for_transmit(the_cipher_list):
    '''
    Packs the cipher List generated by RSA to a one
    string variable for transmission over the network.
    Socks send or receive str or buffer only.
    '''
    combined_cipherblock_string = ""
    for i in range(len(the_cipher_list)):
        combined_cipherblock_string += str(the_cipher_list[i]) + "L"
        
    return combined_cipherblock_string

def unpack_cipherblocks_from_transmit(the_combined_blocks):
    '''
    Unpacks the combined cipher blocks concatenated as s string from transmission.
    '''
    reverted_cipherblock_list = []
    seperated_cipher_blocks = the_combined_blocks.split("L")[:-1]
    for i in range(len(seperated_cipher_blocks)):
        reverted_cipherblock_list.append(int(seperated_cipher_blocks[i]))

    return reverted_cipherblock_list

def recv_end(the_socket):
    '''
    Enables a delimeter to defined that data to be received is not complete.
    This is to fix the issue of not knowing an arbitrary buffer size of data being
    communicated or sent and received on each end.
    
    @author: John Nielsen (code.activestate.com)
    @author: l3og3tz Modified for needed use within application.
    '''
    
    global MSG_END_MARKER
    total_data = [];data = ''  # initialize data to none.
    while True:
            data = the_socket.recv(8192)
            if MSG_END_MARKER in data:
                total_data.append(data[:data.find(MSG_END_MARKER)])
                break
            total_data.append(data)
            if len(total_data) > 1:
                # check if end_of_data was split
                last_pair = total_data[-2] + total_data[-1]
                if MSG_END_MARKER in last_pair:
                    total_data[-2] = last_pair[:last_pair.find(MSG_END_MARKER)]
                    total_data.pop()
                    break
    return ''.join(total_data)

def populated_banned_list():
    '''
    Populated the banned IP list to check when accepting connections
    '''
    
    try:  
        banned_ip_file = open("Banned.txt", "r")
        banned_ip_list = [x.strip("\n") for x in banned_ip_file.readlines()]
    except IOError:
        print "[+] Error opening banned list file"
    return banned_ip_list
        



def add_ip_to_ban_list():
    '''
    Adds an IP address to banned list. If added, this IP 
    address cannot connect to the server. Or server refuses connection from it.
    '''
    banned_ip_list = []
    try:
        banned_ip_file = open("Banned.txt", "r+a")
        while True:
            banned_ip_list = [x.strip("\n") for x in banned_ip_file.readlines()]
            print "\033[1;31mBanned {0} \033[1;m\n".format(banned_ip_list)
            new_ip = raw_input('Enter IP you wish to ban >> ')
            if (new_ip.strip() in banned_ip_list):
                print "\033[1;43m[-] This IP ({0}) is already banned\033[1;m\n"
            else:
                if len(new_ip.strip()) > 0:  
                    banned_ip_file.write("\n" + new_ip.strip())
                    print "\033[1;31m[+] IP ({0}) has been added to banned list\033[1;m\n".format(new_ip)
                else:
                    print "\033[1;31m[+] IP ({0}) is invalid or empty, no changes made\033[1;m\n".format(new_ip)
            cont = raw_input("Do you wish to add another IP: (y/Y or n/N) >> ")
            if(cont == 'n' or cont == 'N'):
                    break
            banned_ip_file = open("Banned.txt", "r+a")
    except IOError:
        print "[-] Problem reading or writing to file\n"
        pass
    finally:
        banned_ip_file.close()
    return
    

def remove_ip_from_ban_list():
    '''
    Removes an IP address from banned list. If removed, this IP 
    address is allowed to connect to the server. Or server refuses connection from it.
    '''
    banned_ip_list = []
    try:
        while True:
            banned_ip_file = open("Banned.txt", "r")
            banned_ip_list = [x.strip("\n") for x in banned_ip_file.readlines()]
            print "\033[1;31mBanned {0} \033[1;m\n".format(banned_ip_list)
            banned_ip_file.close()     
            deleted_ip = raw_input('Enter IP you wish to remove from banned list >> ')
            banned_ip_file = open("Banned.txt", "w")
            if (deleted_ip in banned_ip_list):
                for ip in banned_ip_list:
                    if ip != deleted_ip:
                        banned_ip_file.write(ip + "\n")
                banned_ip_file.close()     
                print "\033[1;43m[+] IP ({0}) Removed IP from banned list\033[1;m\n".format(deleted_ip)
            else:
                print "\033[1;31m[-] This IP ({0}) is not in the banned list\033[1;m\n"
            cont = raw_input("Do you wish to remove another IP: (y/Y or n/N) >> ")
            if(cont == 'n' or cont == 'N'):
                    break
            # banned_ip_file = open("Banned.txt", "r")
    except IOError:
        print "[-] Problem reading or writing to file\n"
        pass
    finally:
        banned_ip_file.close()
    
def receive_incoming_file(the_connection):
    '''
    Receives an incoming file
    @author: __UserName__ original code
    @author: l3og3tz Modified for needed use within application
    
    '''
    accept = raw_input('Accept A File Transfer: (y/Y or n/N) >> ')
    
    try:
        if(accept == 'y' or accept == 'Y'):
            file_name = raw_input("Enter the path location >> ")
            the_connection.send(APPROVAL_CODE)
            f = open(file_name, 'w+')
            while True:
                data = recv_end(the_connection)
                if(data == FILE_TRANSFER_END_CODE):
                    break
                else:
                    f.write(data)
            f.close()
            print '[*] File Successfully Recieved'
        else:
            the_connection.send(DENIAL_CODE)
            print '[*] Telling Other User Transfer Is Denied'
            
    except Exception, e:
        print "[-]", e
        pass

def send_outgoing_file(conn, fileName):
    '''
    Sends out a file
    @author: __UserName__ original code
    @author: l3g3tz modified for needed use within application.
    '''
    try:
        fileData = open(fileName, 'rb')
        print '1'
        for dat in fileData:
            conn.send(dat.replace('\n', ''))
        print '2'
        conn.send(FILE_TRANSFER_END_CODE)
        print '[*] File Successfully Sent'
    except Exception, e:
        print "[-]", e
        pass

def program_info():
    # some basic info and special commands.
    print'-----------------------------------------------------------------\n'

    print """
    
    *************************************************************************
          This is a simple peer to peer chat program that encrypts the
          communication between two parties uses the RSA encryption 
          algorithm.The program was designed as simple LAN chat using 
          python. It has been tested over a WAN connection and can easily
          be converted to a WAN chat when using port forwarding (the chat
          partner who runs the server needs to configure this).
          
          Author: l3og3tz Email:l3og3tz@gmail.com
          
                      ******Special Thanks******
         RSA implementation: Yuhan Hao yuhanhao@seas.upenn.edu
         File Exchange     : __UserName__ http://us3rnam3.webs.com
         Data Transmission 
         over Sockets      : John Nielsen (code.activestate.com)
         
         SEPCIAL COMMANDS: case sensistive
         EXIT : Ends the chat session
         FILE_IN : Prompts for authorization to receive file
         
     ***********************************************************************
        """
        
    raw_input("\nPress [ENTER] To Return To The Main Menu...\n")
    return


if __name__ == "__main__":
    print "To be imported only"
    
     
